<!DOCTYPE html>
<html>
<head>
    <title>Space Limits for Haskell</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="screen.css" media="screen,projection" />
</head>
<body>
<div id="container">
<h1>Space Limits for Haskell</h1>
<div id="paperinfo">
<a href="papers/ezyang14-rlimits.pdf">Draft (PDF)</a> ∙ <a href="papers/ezyang14-rlimits.bib">BibTeX</a> ∙ <a href="http://hackage.haskell.org/trac/ghc/wiki/Commentary/ResourceLimits">Wiki commentary (out of date)</a>
</div>
<div id="content">
<div class="full">
    <p><strong class="abstract">Abstract</strong>
We describe the semantics and implementation of a resource limits
system for Haskell, allowing programmers to create resource
containers which enforce bounded resident memory usage.  Our system
is distinguished by a clear allocator-pays semantics drawn from
previous experience with profiling in Haskell and an implementation
strategy which uses a block-structured heap to organize containers,
allowing us to enforce limits with high accuracy.  To deal with the
problem of deallocating data in a garbage collected heap, we propose
a novel taint-based mechanism that unifies the existing practices of
revocable pointers and killing threads in order to reclaim memory.
Our system is implemented in GHC, a production-strength compiler for Haskell.</p>
</div>
<h2>Code</h2>
<div class="cb">
    <p>We are participating in the PLDI'14 artifact evaluation process,
    so if you are interested in trying out our system with minimal
    fuss, check out our <a href="https://github.com/ezyang/pldi14-rlimits-aec">artifact
        description page</a> for a ready-made VM image, a tutorial and evaluation code
    from the paper.
    </p>
    <p>To get and compile the code yourself, check the <code>ghc-rlimits-20130210</code>
    tag of <a href="https://github.com/ezyang/ghc/tree/ghc-rlimits-20130210">ghc</a>
    and <a href="https://github.com/ezyang/packages-integer-gmp/commit/26d4064328ba8e62aa4d218c2367ceb22c2169a9">this patch to integer-gmp</a> (set your other branches to <code>ghc-7.8</code>).  The compilation process is the same
    as for <a href="https://ghc.haskell.org/trac/ghc/wiki/Building">normal GHC</a>, with the caveat that it will not work
    for 32-bit platforms.</p>
</div>
<h2>FAQ</h2>
<div class="cb">

    <p><strong>I don't use Haskell.  Why should I care?</strong></p>
    <p>
    If you are an implementor of any programming language, you might
    still be interested in the technique used in this paper.  The core
    of our implementation relies only on a
    <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel-gc/">block structured heap</a>,
    which allows us to create many regions in the heap
    quite cheaply.  Your language probably doesn't use a block structured
    heap, but you should consider it: the design is very flexible, and
    in retrospect has been considered one of the "best decisions"
    to have been made for Haskell's storage manager.  Haskell presents
    both challenges and opportunities for our system, but the underlying
    technique is quite general.</p>

    <p><strong>Why not use an OS mechanism like rlimits?</strong></p><p>
    Mechanisms like rlimits work well in many cases, but they impose conceptual
    and runtime overhead.  The conceptual overhead comes from needing to restructure
    an application into multiple processes to apply per-process limits: a mechanism
    that is built into a language is much easier to use.  The runtime overhead
    comes from the overhead of processes and inter-process communication; in
    a single-runtime system like ours there is no overhead beyond cache effects.
    </p>

</div>
<h2>History</h2>
<div class="cb">
    <p>We have a <a href="papers/ezyang13-rlimits.pdf">previous version
    of the paper entitled "Resource Limits for Haskell"</a> (<a href="papers/ezyang13-rlimits.bib">BibTeX</a>), which was rejected from ICFP'13, which described
    an old iteration of the system, which directly utilized GHC's cost-center profiling in
    order to implement resource limits.  It was a very cute implementation, but it was
    very costly, since it required all code to be compiled with profiling.  We've since
    reimplemented the system to take advantage of GHC's block-structured heap, for a
    sizeable speed increase.</p>
</div>
</body>
</html>
