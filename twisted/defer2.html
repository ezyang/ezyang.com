<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html  PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'  'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'><html lang="en" xmlns="http://www.w3.org/1999/xhtml">
  <head>
<title>Twisted Documentation: Guide to twisted.internet.defer</title>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
  </head>

  <body bgcolor="white">
    <h1 class="title">Guide to twisted.internet.defer</h1>
    <div class="toc"><ol><li><a href="#auto0">Deferreds standardize callbacks</a></li><li><a href="#auto1">Deferred</a></li><ul><li><a href="#auto2">Callbacks</a></li><li><a href="#auto3">Errbacks</a></li><li><a href="#auto4">Callbacks and errbacks</a></li><li><a href="#auto5">Chaining callbacks</a></li><li><a href="#auto6">Fluent interface</a></li></ul><li><a href="#auto7">Chaining Deferreds</a></li><ul><li><a href="#auto8">Chaining in Pictures</a></li><li><a href="#auto9">Dependencies</a></li><li><a href="#auto10">Looping</a></li><li><a href="#auto11">Lambdas</a></li></ul><li><a href="#auto12">Composing Deferreds</a></li><ul><li><a href="#auto13">The implementation of a DeferredList</a></li><li><a href="#auto14">Making your own deferreds</a></li><li><a href="#auto15">Simple case: batons</a></li></ul></ol></div>
    <div class="content">

<span/>

<p>This document addresses Twisted's
implementation of Deferred objects in
<code class="API"><a href="twisted.internet.defer.Deferred" title="twisted.internet.defer.Deferred">twisted.internet.defer.Deferred</a></code>.  It
assumes familiarity with the basics of event loops and
asynchronous programming.</p>

<h2>Deferreds standardize callbacks<a name="auto0"/></h2>

<p>Callbacks are the lingua franca of asynchronous programming:
any time you need to process the result of a non-blocking operation,
you give that operation a callback for it to call when it has
finished processing and has a result for you.</p>

<p>If you were implementing an asynchronous function from scratch,
you might be tempted to define it like this:</p>

<pre class="python"><p class="py-linenumber">1
2
</p><span class="py-src-keyword">def</span> <span class="py-src-identifier">nonblocking_call</span>(<span class="py-src-parameter">input</span>, <span class="py-src-parameter">on_success</span>, <span class="py-src-parameter">on_error</span>):
    <span class="py-src-keyword">pass</span>
</pre>

<p>The person using this code, then, would pass the functions he
wanted called to this function at call time, like this:</p>

<pre class="python"><p class="py-linenumber">1
2
3
4
5
</p><span class="py-src-keyword">def</span> <span class="py-src-identifier">success_handler</span>(<span class="py-src-parameter">result</span>):
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;Success: %s&quot;</span> % <span class="py-src-variable">result</span>
<span class="py-src-keyword">def</span> <span class="py-src-identifier">error_handler</span>(<span class="py-src-parameter">error</span>):
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;Failure: %s&quot;</span> % <span class="py-src-variable">str</span>(<span class="py-src-variable">error</span>)
<span class="py-src-variable">nonblocking_call</span>(<span class="py-src-string">&quot;input&quot;</span>, <span class="py-src-variable">success_handler</span>, <span class="py-src-variable">error_handler</span>)
</pre>

<p>This works quite well for many simple cases, where you only
need one success handler and one error handler, and the nonblocking
call is a relatively one off function.</p>

<p>But what if you are Twisted and you have many nonblocking functions:
do you force every one of these functions to have a <code>on_success</code>
and <code>on_error</code>
parameter?  What if you want to perform a calculation on the result
of the <code>success_handler</code>: do you write all of the code into a bigger
<code>success_handler</code> and increase the indentation?</p>

<p>Twisted's elegant solution to this problem is Deferreds.  Since
the nonblocking call doesn't have a meaningful return value anyway (remember,
it's asynchronous; it can return before it has a result), we return
a Deferred which you can attach callbacks to.</p>

<pre class="python"><p class="py-linenumber">1
2
3
</p><span class="py-src-variable">d</span> = <span class="py-src-variable">nonblocking_call</span>(<span class="py-src-string">&quot;input&quot;</span>)
<span class="py-src-variable">d</span>.<span class="py-src-variable">addCallback</span>(<span class="py-src-variable">success_handler</span>)
<span class="py-src-variable">d</span>.<span class="py-src-variable">addErrback</span>(<span class="py-src-variable">error_handler</span>)
</pre>

<p>The Deferred object doesn't do anything that you couldn't have done
with the two callback parameters.  This point is worth repeating: Deferred
is an abstraction over callback parameters: it does nothing magical
and is not, itself, asynchronous.  It is a merely a standard:
if a function returns a Deferred,
you <em>know</em> that you are dealing with an asynchronous function,
and you know exactly what its API for adding callbacks is.</p>

<h2>Deferred<a name="auto1"/></h2>

<h3>Callbacks<a name="auto2"/></h3>

<p>At its very simplest, the Deferred has a single callback attached to it, which
gets invoked with the result as an argument when it becomes available:</p>

<table class="compare">
    <tr>
        <th colspan="1" rowspan="1">Synchronous</th>
        <th colspan="1" rowspan="1">Asynchronous</th>
    </tr>
    <tr>
        <td colspan="1" rowspan="1"><pre class="python"><p class="py-linenumber">1
2
</p><span class="py-src-variable">value</span> = <span class="py-src-variable">synchronous_operation</span>()
<span class="py-src-variable">process</span>(<span class="py-src-variable">value</span>)
</pre></td>
        <td colspan="1" rowspan="1"><pre class="python"><p class="py-linenumber">1
2
</p><span class="py-src-variable">d</span> = <span class="py-src-variable">asynchronous_operation</span>()
<span class="py-src-variable">d</span>.<span class="py-src-variable">addCallback</span>(<span class="py-src-variable">process</span>)
</pre></td>
    </tr>
</table>

<h3>Errbacks<a name="auto3"/></h3>

<p>Error handling is an ever present concern in synchronous code.  Deferred
implements a system of <strong>errbacks</strong> in order to simulate Python
try/except blocks.  Just like in synchronous code, you <em>always</em> should
register an errback in order to deal with an error gracefully.</p>

<table class="compare">
    <tr>
        <th colspan="1" rowspan="1">Synchronous</th>
        <th colspan="1" rowspan="1">Asynchronous</th>
    </tr>
    <tr>
        <td colspan="1" rowspan="1"><pre class="python"><p class="py-linenumber">1
2
3
4
</p><span class="py-src-keyword">try</span>:
    <span class="py-src-variable">synchronous_operation</span>()
<span class="py-src-keyword">except</span> <span class="py-src-variable">UserError</span> <span class="py-src-keyword">as</span> <span class="py-src-variable">e</span>:
    <span class="py-src-variable">handle_error</span>(<span class="py-src-variable">e</span>)
</pre></td>
        <td colspan="1" rowspan="1"><pre class="python"><p class="py-linenumber">1
2
3
4
5
</p><span class="py-src-variable">d</span> = <span class="py-src-variable">asynchronous_operation</span>()
<span class="py-src-keyword">def</span> <span class="py-src-identifier">handle_twisted_error</span>(<span class="py-src-parameter">failure</span>):
    <span class="py-src-variable">e</span> = <span class="py-src-variable">failure</span>.<span class="py-src-variable">trap</span>(<span class="py-src-variable">UserError</span>)
    <span class="py-src-variable">handle_error</span>(<span class="py-src-variable">e</span>)
<span class="py-src-variable">d</span>.<span class="py-src-variable">addErrback</span>(<span class="py-src-variable">handle_twisted_error</span>)
</pre></td>
    </tr>
</table>

<p>There are plenty of things going on here:</p>

<ul>
    <li>Instead of being passed an exception object, which is roughly
    analogous to the result in the no error case, you are passed a
    <code>twisted.python.failure.Failure</code> object.  This is roughly
    a wrapper around the standard <code>Exception</code> with a few
    crucial enhancements to make it useful in an asynchronous context.</li>

    <li>Consequently, we pull out the real exception by using
    <code>failure.trap(UserError)</code>.  This is the userland implementation
    of <code>except</code>; if the exception is not trapped, it gets
    re-thrown and our errback is bypassed.  </li>

    <li>You can trap multiple types of exceptions by simply calling trap
    with multiple arguments, e.g. <code>failure.trap(UserError, OtherUserError)</code></li>
</ul>

<p>Omitting the trap declaration is equivalent to a catch-all
except block:</p>

<table class="compare">
    <tr>
        <th colspan="1" rowspan="1">Synchronous</th>
        <th colspan="1" rowspan="1">Asynchronous</th>
    </tr>
    <tr>
        <td colspan="1" rowspan="1"><pre class="python"><p class="py-linenumber">1
2
3
4
5
</p><span class="py-src-keyword">try</span>:
    <span class="py-src-variable">synchronous_operation</span>()
<span class="py-src-keyword">except</span>:
    <span class="py-src-variable">handle_error</span>()
    <span class="py-src-keyword">raise</span>
</pre></td>
        <td colspan="1" rowspan="1"><pre class="python"><p class="py-linenumber">1
2
3
4
5
</p><span class="py-src-variable">d</span> = <span class="py-src-variable">asynchronous_operation</span>()
<span class="py-src-keyword">def</span> <span class="py-src-identifier">handle_twisted_error</span>(<span class="py-src-parameter">failure</span>):
    <span class="py-src-variable">handle_error</span>()
    <span class="py-src-keyword">return</span> <span class="py-src-variable">failure</span>
<span class="py-src-variable">d</span>.<span class="py-src-variable">addErrback</span>(<span class="py-src-variable">handle_twisted_error</span>)
</pre></td>
    </tr>
</table>

<p>Notice that in order to re-raise the exception, we simply
return it from our errback handler.  Deferred will notice that it
is the type of a failure object, and act accordingly.
You can <em>also</em> throw an exception and Deferred will
handle it properly:</p>

<pre class="python"><p class="py-linenumber">1
2
3
4
5
6
</p><span class="py-src-variable">d</span> = <span class="py-src-variable">asynchronous_operation</span>()
<span class="py-src-keyword">def</span> <span class="py-src-identifier">handle_twisted_error</span>(<span class="py-src-parameter">failure</span>):
    <span class="py-src-variable">status</span> = <span class="py-src-variable">handle_error</span>(<span class="py-src-variable">failure</span>.<span class="py-src-variable">value</span>)
    <span class="py-src-keyword">if</span> <span class="py-src-keyword">not</span> <span class="py-src-variable">status</span>:
        <span class="py-src-keyword">raise</span> <span class="py-src-variable">UserError</span>
<span class="py-src-variable">d</span>.<span class="py-src-variable">addErrback</span>(<span class="py-src-variable">handle_twisted_error</span>)
</pre>

<p>If you would like to re-raise the original error, it is preferred to use
<code>failure.raiseException()</code>, which preserves traceback information
if available.</p>

<p>Failure has another convenience function, <code>check()</code>, which
makes it easier to simulate multiple <code>except</code> blocks:</p>

<table class="compare">
    <tr>
        <th colspan="1" rowspan="1">Synchronous</th>
        <th colspan="1" rowspan="1">Asynchronous</th>
    </tr>
    <tr>
        <td colspan="1" rowspan="1"><pre class="python"><p class="py-linenumber">1
2
3
4
5
6
</p><span class="py-src-keyword">try</span>:
    <span class="py-src-variable">synchronous_operation</span>()
<span class="py-src-keyword">except</span> <span class="py-src-variable">UserError</span>:
    <span class="py-src-variable">handle_error</span>()
<span class="py-src-keyword">except</span> <span class="py-src-variable">AnotherUserError</span>:
    <span class="py-src-variable">handler_another_error</span>()
</pre></td>
        <td colspan="1" rowspan="1"><pre class="python"><p class="py-linenumber">1
2
3
4
5
6
7
8
9
</p><span class="py-src-variable">d</span> = <span class="py-src-variable">asynchronous_operation</span>()
<span class="py-src-keyword">def</span> <span class="py-src-identifier">handle_twisted_error</span>(<span class="py-src-parameter">failure</span>):
    <span class="py-src-keyword">if</span> <span class="py-src-variable">failure</span>.<span class="py-src-variable">check</span>(<span class="py-src-variable">UserError</span>):
        <span class="py-src-variable">handle_error</span>()
    <span class="py-src-keyword">elif</span> <span class="py-src-variable">failure</span>.<span class="py-src-variable">check</span>(<span class="py-src-variable">AnotherUserError</span>):
        <span class="py-src-variable">handle_another_error</span>()
    <span class="py-src-keyword">else</span>:
        <span class="py-src-variable">failure</span>.<span class="py-src-variable">raiseException</span>()
<span class="py-src-variable">d</span>.<span class="py-src-variable">addErrback</span>(<span class="py-src-variable">handle_twisted_error</span>)
</pre></td>
    </tr>
</table>

<h3>Callbacks and errbacks<a name="auto4"/></h3>

<p>In most cases, you'll want to perform some processing on the deferred
result <em>as well</em> as have error handling.  As you may have guessed,
this simply means you should define both a callback and an errback.</p>

<table class="compare">
    <tr>
        <th colspan="1" rowspan="1">Synchronous</th>
        <th colspan="1" rowspan="1">Asynchronous</th>
    </tr>
    <tr>
        <td colspan="1" rowspan="1"><pre class="python"><p class="py-linenumber">1
2
3
4
5
</p><span class="py-src-keyword">try</span>:
    <span class="py-src-variable">value</span> = <span class="py-src-variable">synchronous_operation</span>()
    <span class="py-src-variable">process</span>(<span class="py-src-variable">value</span>)
<span class="py-src-keyword">except</span> <span class="py-src-variable">UserError</span> <span class="py-src-keyword">as</span> <span class="py-src-variable">e</span>:
    <span class="py-src-variable">handle_error</span>(<span class="py-src-variable">e</span>)
</pre></td>
        <td colspan="1" rowspan="1"><pre class="python"><p class="py-linenumber">1
2
3
4
5
6
</p><span class="py-src-variable">d</span> = <span class="py-src-variable">asynchronous_operation</span>()
<span class="py-src-variable">d</span>.<span class="py-src-variable">addCallback</span>(<span class="py-src-variable">process</span>)
<span class="py-src-keyword">def</span> <span class="py-src-identifier">handle_twisted_error</span>(<span class="py-src-parameter">failure</span>):
    <span class="py-src-variable">e</span> = <span class="py-src-variable">failure</span>.<span class="py-src-variable">trap</span>(<span class="py-src-variable">UserError</span>)
    <span class="py-src-variable">handle_error</span>(<span class="py-src-variable">e</span>)
<span class="py-src-variable">d</span>.<span class="py-src-variable">addErrback</span>(<span class="py-src-variable">handle_twisted_error</span>)
</pre></td>
    </tr>
</table>

<p>Notice that in the synchronous version, <code>process</code>
is <em>inside</em> the try..except block.  This translates over
to the asynchronous code: if
<code>process</code> throws an exception, <code>handle_twisted_error</code>
will get a <code>Failure</code> object corresponding to that
exception.  The errback could handle <em>either</em> an error
from the asynchronous operation or from our callback.
Why does this happen?  This is because
Deferreds chain callbacks.</p>

<h3>Chaining callbacks<a name="auto5"/></h3>

<p>A common pattern in programs is the notion of one function
returning an intermediate result, which gets passed to another
function to calculate a further result, and so forth.  Such a
chain of data processing entities is called a <em>pipeline</em>,
and Deferreds are ideally suited for modeling them.</p>

<table class="compare">
    <tr>
        <th colspan="1" rowspan="1">Synchronous</th>
        <th colspan="1" rowspan="1">Asynchronous</th>
    </tr>
    <tr>
        <td colspan="1" rowspan="1"><pre class="python"><p class="py-linenumber">1
2
3
</p><span class="py-src-variable">value</span> = <span class="py-src-variable">synchronous_operation</span>()
<span class="py-src-variable">value2</span> = <span class="py-src-variable">process</span>(<span class="py-src-variable">value</span>)
<span class="py-src-variable">another_process</span>(<span class="py-src-variable">value2</span>) <span class="py-src-comment"># value2, not value!</span>
</pre></td>
        <td colspan="1" rowspan="1"><pre class="python"><p class="py-linenumber">1
2
3
</p><span class="py-src-variable">d</span> = <span class="py-src-variable">asynchronous_operation</span>()
<span class="py-src-variable">d</span>.<span class="py-src-variable">addCallback</span>(<span class="py-src-variable">process</span>)
<span class="py-src-variable">d</span>.<span class="py-src-variable">addCallback</span>(<span class="py-src-variable">another_process</span>)
</pre></td>
    </tr>
</table>

<p>This behavior makes the name <code>addCallback</code>
slightly misleading, since each of these
callbacks will get a different result.  If you would like to multiplex
(have multiple callbacks handle the same result), you should code
this directly into your callback:</p>

<table class="compare">
    <tr>
        <th colspan="1" rowspan="1">Synchronous</th>
        <th colspan="1" rowspan="1">Asynchronous</th>
    </tr>
    <tr>
        <td colspan="1" rowspan="1"><pre class="python"><p class="py-linenumber">1
2
3
</p><span class="py-src-variable">value</span> = <span class="py-src-variable">synchronous_operation</span>()
<span class="py-src-variable">process</span>(<span class="py-src-variable">value</span>)
<span class="py-src-variable">another_process</span>(<span class="py-src-variable">value</span>)
</pre></td>
        <td colspan="1" rowspan="1"><pre class="python"><p class="py-linenumber">1
2
3
4
5
</p><span class="py-src-variable">d</span> = <span class="py-src-variable">asynchronous_operation</span>()
<span class="py-src-keyword">def</span> <span class="py-src-identifier">multi_process</span>(<span class="py-src-parameter">value</span>):
    <span class="py-src-variable">process</span>(<span class="py-src-variable">value</span>)
    <span class="py-src-keyword">return</span> <span class="py-src-variable">another_process</span>(<span class="py-src-variable">value</span>)
<span class="py-src-variable">d</span>.<span class="py-src-variable">addCallback</span>(<span class="py-src-variable">multi_process</span>)
</pre></td>
    </tr>
</table>

<p>Errbacks work similarly, but instead of pipelining values
through multiple functions, they create nested try..except
blocks:</p>

<table class="compare">
    <tr>
        <th colspan="1" rowspan="1">Synchronous</th>
        <th colspan="1" rowspan="1">Asynchronous</th>
    </tr>
    <tr>
        <td colspan="1" rowspan="1"><pre class="python"><p class="py-linenumber">1
2
3
4
5
6
7
</p><span class="py-src-keyword">try</span>:
    <span class="py-src-keyword">try</span>:
        <span class="py-src-variable">synchronous_operation</span>()
    <span class="py-src-keyword">except</span> <span class="py-src-variable">UserError</span> <span class="py-src-keyword">as</span> <span class="py-src-variable">e</span>:
        <span class="py-src-variable">handle_error</span>(<span class="py-src-variable">e</span>)
<span class="py-src-keyword">except</span> <span class="py-src-variable">AnotherUserError</span> <span class="py-src-keyword">as</span> <span class="py-src-variable">e</span>:
    <span class="py-src-variable">handle_another_error</span>(<span class="py-src-variable">e</span>)
</pre></td>
        <td colspan="1" rowspan="1"><pre class="python"><p class="py-linenumber"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
</p><span class="py-src-variable">d</span> = <span class="py-src-variable">asynchronous_operation</span>()

<span class="py-src-keyword">def</span> <span class="py-src-identifier">handle_twisted_error</span>(<span class="py-src-parameter">failure</span>):
    <span class="py-src-variable">e</span> = <span class="py-src-variable">failure</span>.<span class="py-src-variable">trap</span>(<span class="py-src-variable">UserError</span>)
    <span class="py-src-variable">handle_error</span>(<span class="py-src-variable">e</span>)
<span class="py-src-variable">d</span>.<span class="py-src-variable">addErrback</span>(<span class="py-src-variable">handle_twisted_error</span>)

<span class="py-src-keyword">def</span> <span class="py-src-identifier">handle_twisted_another_error</span>(<span class="py-src-parameter">failure</span>):
    <span class="py-src-variable">e</span> = <span class="py-src-variable">failure</span>.<span class="py-src-variable">trap</span>(<span class="py-src-variable">AnotherUserError</span>)
    <span class="py-src-variable">handle_another_error</span>(<span class="py-src-variable">e</span>)
<span class="py-src-variable">d</span>.<span class="py-src-variable">addErrback</span>(<span class="py-src-variable">handle_twisted_another_error</span>)
</pre></td>
    </tr>
</table>

<p>Now, we can do tricky things with chaining callbacks and errbacks.
The following code makes it possible for the errback function to gracefully
provide the result of the computation, even though it failed (perhaps
from a cache).</p>

<table class="compare">
    <tr>
        <th colspan="1" rowspan="1">Synchronous</th>
        <th colspan="1" rowspan="1">Asynchronous</th>
    </tr>
    <tr>
        <td colspan="1" rowspan="1"><pre class="python"><p class="py-linenumber">1
2
3
4
5
</p><span class="py-src-keyword">try</span>:
    <span class="py-src-variable">value</span> = <span class="py-src-variable">synchronous_operation</span>()
<span class="py-src-keyword">except</span> <span class="py-src-variable">UserError</span> <span class="py-src-keyword">as</span> <span class="py-src-variable">e</span>:
    <span class="py-src-variable">value</span> = <span class="py-src-variable">handle_error</span>(<span class="py-src-variable">e</span>)
<span class="py-src-variable">process</span>(<span class="py-src-variable">value</span>)
</pre></td>
        <td colspan="1" rowspan="1"><pre class="python"><p class="py-linenumber">1
2
3
4
5
6
</p><span class="py-src-variable">d</span> = <span class="py-src-variable">asynchronous_operation</span>()
<span class="py-src-keyword">def</span> <span class="py-src-identifier">handle_twisted_error</span>(<span class="py-src-parameter">failure</span>):
    <span class="py-src-variable">e</span> = <span class="py-src-variable">failure</span>.<span class="py-src-variable">trap</span>(<span class="py-src-variable">UserError</span>)
    <span class="py-src-keyword">return</span> <span class="py-src-variable">handle_error</span>(<span class="py-src-variable">e</span>)
<span class="py-src-variable">d</span>.<span class="py-src-variable">addErrback</span>(<span class="py-src-variable">handle_twisted_error</span>)
<span class="py-src-variable">d</span>.<span class="py-src-variable">addCallback</span>(<span class="py-src-variable">process</span>)
</pre></td>
    </tr>
</table>

<p>This code introduces a new function: <code>addCallbacks</code>, which
adds both a callback and an errback.  Unlike adding them individually, if
the callback errors, the errback will not receive the error, and if the
errback returns a valid result, the callback will not receive it.  They
are completely isolated from each other.</p>

<table class="compare">
    <tr>
        <th colspan="1" rowspan="1">Synchronous</th>
        <th colspan="1" rowspan="1">Asynchronous</th>
    </tr>
    <tr>
        <td colspan="1" rowspan="1"><pre class="python"><p class="py-linenumber">1
2
3
4
5
6
</p><span class="py-src-keyword">try</span>:
    <span class="py-src-variable">value</span> = <span class="py-src-variable">synchronous_operation</span>()
<span class="py-src-keyword">except</span> <span class="py-src-variable">UserError</span> <span class="py-src-keyword">as</span> <span class="py-src-variable">e</span>:
    <span class="py-src-variable">handle_error</span>(<span class="py-src-variable">e</span>)
<span class="py-src-keyword">else</span>:
    <span class="py-src-variable">process</span>(<span class="py-src-variable">value</span>)
</pre></td>
        <td colspan="1" rowspan="1"><pre class="python"><p class="py-linenumber">1
2
3
4
5
</p><span class="py-src-variable">d</span> = <span class="py-src-variable">asynchronous_operation</span>()
<span class="py-src-keyword">def</span> <span class="py-src-identifier">handle_twisted_error</span>(<span class="py-src-parameter">failure</span>):
    <span class="py-src-variable">e</span> = <span class="py-src-variable">failure</span>.<span class="py-src-variable">trap</span>(<span class="py-src-variable">UserError</span>)
    <span class="py-src-variable">handle_error</span>(<span class="py-src-variable">e</span>)
<span class="py-src-variable">d</span>.<span class="py-src-variable">addCallbacks</span>(<span class="py-src-variable">process</span>, <span class="py-src-variable">handle_twisted_error</span>)
</pre></td>
    </tr>
</table>

<p>Let's stick our hand inside the black box and see what actually is
happening.  The order in which we add callbacks and errbacks is obviously
influencing the end behavior.  Here's why:</p>

<p>Internally, Deferred stores callbacks and errbacks in a list of
callback/errback tuples.  When you call <code>addCallback</code>
or <code>addErrback</code>, you are not adding a callback/errback
to separate stacks; instead, Deferred wraps your callback into a
tuple (substituting a &quot;pass through&quot; function for the missing
callback/errback) and sticks this on the callback/errback tuple list.
</p>

<p>The result from the asynchronous function will either
be a <code>Failure</code> object, or some
other Python value.  If it is the former, Deferred will call
your errback function in the tuple with the result; the latter will result
in a call to the callback function in the tuple.  The function
call itself can result in two end results, another failure (either
by returning a Failure object or by raising an Exception) or
a regular Python value.  Deferred will then move to the next
tuple and repeat until there are no more tuples left.</p>

<p>Take the following code as an example:</p>

<pre class="python"><p class="py-linenumber">1
2
3
4
5
</p><span class="py-src-variable">d</span> = <span class="py-src-variable">asynchronous_operation</span>()
<span class="py-src-variable">d</span>.<span class="py-src-variable">addCallback</span>(<span class="py-src-variable">callback1</span>) <span class="py-src-comment"># tuple 1</span>
<span class="py-src-variable">d</span>.<span class="py-src-variable">addCallback</span>(<span class="py-src-variable">callback2</span>) <span class="py-src-comment"># tuple 2</span>
<span class="py-src-variable">d</span>.<span class="py-src-variable">addErrback</span>(<span class="py-src-variable">errback3</span>) <span class="py-src-comment"># tuple 3</span>
<span class="py-src-variable">d</span>.<span class="py-src-variable">addCallbacks</span>(<span class="py-src-variable">callback4</span>, <span class="py-src-variable">errback4</span>) <span class="py-src-comment"># tuple 4</span>
</pre>

<p>Consider two possible scenarios.  First, success:</p>

<ol>
    <li>The asynchronous operation succeeds with a result of <code>&quot;Foo&quot;</code>.</li>
    <li>No failure. We give <code>&quot;Foo&quot;</code> to the callback of tuple 1,
    <code>callback1</code>.  It returns <code>(&quot;Foo&quot;, 123)</code>.</li>
    <li>No failure. We give <code>(&quot;Foo&quot;, 123)</code> to the callback of tuple 2,
    <code>callback2</code>.  It returns <code>&quot;Foo123&quot;</code>.</li>
    <li>No failure. We give <code>&quot;Foo123&quot;</code> to the callback of tuple 3,
    which happens to be a pass through function.  It returns
    <code>&quot;Foo123&quot;</code>.</li>
    <li>No failure. We give <code>&quot;Foo123&quot;</code>
    to the callback of tuple 4, <code>callback4</code>.  It does something, but
    the return value is not given to anyone.  </li>
</ol>

<p>What about failure?</p>

<ol>
    <li>The asynchronous operation fails, and a Failure object is constructed.</li>
    <li>Failure. We give the failure object to the errback of tuple 1, which
    happens to be pass through function.  It returns the failure object.</li>
    <li>Failure. We give the failure object to the errback of tuple 2, which is
    also a pass through function.  It returns the failure object.</li>
    <li>Failure. We give the failure object to the errback of tuple 3,
    <code>errback3</code>.  It acknowledges and logs the error.  It doesn't
    return anything.</li>
    <li>No failure (remember, <code>None</code> is a
    valid result value!) We give <code>None</code> to the callback of tuple 4,
    <code>callback4</code>.</li>
</ol>

<p>Think of your callback/errback chains as parallel
pipes of execution, which could transfer to one another at any point.  As
a parting word, here is a use of one convenience function, <code>addBoth</code>.</p>

<table class="compare">
    <tr>
        <th colspan="1" rowspan="1">Synchronous</th>
        <th colspan="1" rowspan="1">Asynchronous</th>
    </tr>
    <tr>
        <td colspan="1" rowspan="1"><pre class="python"><p class="py-linenumber">1
2
3
4
</p><span class="py-src-keyword">try</span>:
    <span class="py-src-variable">synchronous_operation</span>()
<span class="py-src-keyword">finally</span>:
    <span class="py-src-variable">cleanup</span>()
</pre></td>
        <td colspan="1" rowspan="1"><pre class="python"><p class="py-linenumber">1
2
</p><span class="py-src-variable">d</span> = <span class="py-src-variable">asynchronous_operation</span>()
<span class="py-src-variable">d</span>.<span class="py-src-variable">addBoth</span>(<span class="py-src-keyword">lambda</span> <span class="py-src-variable">x</span>: <span class="py-src-variable">cleanup</span>())
</pre></td>
    </tr>
</table>

<p>The lambda is simply a convenient way to avoid passing <code>x</code> to
<code>clean()</code> (lest Python raise a <code>TypeError</code>).</p>

<h3>Fluent interface<a name="auto6"/></h3>

<p>Deferred implements a fluent interface for adding callbacks, where the
return value of <code>addCallback</code>, <code>addErrback</code> or any
other similar method is the object itself (<code>return self</code>).  This means you can
write this:</p>

<pre class="python"><p class="py-linenumber">1
2
</p><span class="py-src-variable">d</span> = <span class="py-src-variable">asynchronous_operation</span>()
<span class="py-src-variable">d</span>.<span class="py-src-variable">addCallback</span>(<span class="py-src-variable">f1</span>).<span class="py-src-variable">addCallback</span>(<span class="py-src-variable">f2</span>).<span class="py-src-variable">addCallback</span>(<span class="py-src-variable">f3</span>)
</pre>

<p>which is equivalent to:</p>

<pre class="python"><p class="py-linenumber">1
2
3
4
</p><span class="py-src-variable">d</span> = <span class="py-src-variable">asynchronous_operation</span>()
<span class="py-src-variable">d</span>.<span class="py-src-variable">addCallback</span>(<span class="py-src-variable">f1</span>)
<span class="py-src-variable">d</span>.<span class="py-src-variable">addCallback</span>(<span class="py-src-variable">f2</span>)
<span class="py-src-variable">d</span>.<span class="py-src-variable">addCallback</span>(<span class="py-src-variable">f3</span>)
</pre>

<p>Use of this style is a matter of taste and consistency.</p>

<h2>Chaining Deferreds<a name="auto7"/></h2>

<p>All of the examples, to this point, have been focused around
a single asynchronous operation, and the synchronous post-processing of that
operation.  However, in the real world, you will often need to
run multiple asynchronous operations, one after the other.  For
example, if you
make an HTTP request, and find out that the request is a redirect,
you need to make another (asynchronous) HTTP request.</p>

<p>Our code, then, is fatally hobbled if we can't easily chain
deferreds together. With the framework we setup previously,
we could implement something along the lines of having the
callback call the next asynchronous function, and then setup
the callbacks on the deferreds <em>that</em> function returned.</p>

<table class="compare">
    <tr>
        <th colspan="1" rowspan="1">Synchronous</th>
        <th colspan="1" rowspan="1">Asynchronous</th>
    </tr>
    <tr>
        <td colspan="1" rowspan="1"><pre class="python"><p class="py-linenumber">1
2
3
</p><span class="py-src-variable">value</span>  = <span class="py-src-variable">synchronous_operation_a</span>()
<span class="py-src-variable">value2</span> = <span class="py-src-variable">synchronous_operation_b</span>(<span class="py-src-variable">value</span>)
<span class="py-src-variable">process</span>(<span class="py-src-variable">value2</span>)
</pre></td>
        <td colspan="1" rowspan="1"><pre class="python"><p class="py-linenumber">1
2
3
4
5
</p><span class="py-src-variable">d</span> = <span class="py-src-variable">asynchronous_operation_a</span>()
<span class="py-src-keyword">def</span> <span class="py-src-identifier">chain</span>(<span class="py-src-parameter">result</span>):
    <span class="py-src-variable">d</span> = <span class="py-src-variable">asynchronous_operation_b</span>(<span class="py-src-variable">result</span>)
    <span class="py-src-variable">d</span>.<span class="py-src-variable">addCallback</span>(<span class="py-src-variable">process</span>)
<span class="py-src-variable">d</span>.<span class="py-src-variable">addCallback</span>(<span class="py-src-variable">chain</span>)
</pre></td>
    </tr>
</table>

<p>But we just spent the first section explaining our wonderful system
of multiple callbacks and errbacks and, as you might notice, there isn't
actually a way to get <code>chain</code> to return the value of process in this
example without making it synchronous.</p>

<p>To make this work, Twisted does something special:  it lets callbacks
return Deferred, and treats it to mean, &quot;this callback doesn't have the
answer yet, but when this Deferred fires it will!&quot;</p>

<table class="compare">
    <tr>
        <th colspan="1" rowspan="1">Synchronous</th>
        <th colspan="1" rowspan="1">Asynchronous</th>
    </tr>
    <tr>
        <td colspan="1" rowspan="1"><pre class="python"><p class="py-linenumber">1
2
3
</p><span class="py-src-variable">value</span>  = <span class="py-src-variable">synchronous_operation_a</span>()
<span class="py-src-variable">value2</span> = <span class="py-src-variable">synchronous_operation_b</span>(<span class="py-src-variable">value</span>)
<span class="py-src-variable">process</span>(<span class="py-src-variable">value2</span>)
</pre></td>
        <td colspan="1" rowspan="1"><pre class="python"><p class="py-linenumber">1
2
3
</p><span class="py-src-variable">d</span> = <span class="py-src-variable">asynchronous_operation_a</span>()
<span class="py-src-variable">d</span>.<span class="py-src-variable">addCallback</span>(<span class="py-src-variable">asynchronous_operation_b</span>)
<span class="py-src-variable">d</span>.<span class="py-src-variable">addCallback</span>(<span class="py-src-variable">process</span>)
</pre></td>
    </tr>
</table>

<p>Written a little more explicitly (in case you're still squeamish
about higher order functions), the asynchronous code is equivalent to this:</p>

<pre class="python"><p class="py-linenumber">1
2
3
4
5
</p><span class="py-src-variable">d</span> = <span class="py-src-variable">asynchronous_operation_a</span>()
<span class="py-src-keyword">def</span> <span class="py-src-identifier">chain</span>(<span class="py-src-parameter">result</span>):
    <span class="py-src-keyword">return</span> <span class="py-src-variable">asynchronous_operation_b</span>(<span class="py-src-variable">result</span>)
<span class="py-src-variable">d</span>.<span class="py-src-variable">addCallback</span>(<span class="py-src-variable">chain</span>)
<span class="py-src-variable">d</span>.<span class="py-src-variable">addCallback</span>(<span class="py-src-variable">process</span>)
</pre>

<p>Here is the mantra:  <em>Callbacks and errbacks can return deferreds</em>.</p>

<h3>Chaining in Pictures<a name="auto8"/></h3>

<p>We're now going to introduce some visual aids to see how you can
use deferred chaining to modify program flow.  We'll represent Deferred
objects as &quot;pipes,&quot; that is, a series of callbacks that take some input,
process it in turn, and then return some output.</p>

<div style="text-align:center;"><img alt="Plain old deferred object" src="defer.dot.png"/></div>

<p>This is a Deferred that we instantiated from scratch; it doesn't do
anything and unless we explicitly call it, it will never
run (in the next section, Composing Deferreds, we will see why Deferred objects
like this can be useful).  In many other cases, the function we called to
get this deferred object promised to call back at some point: we'll represent as
the red text &quot;Asynchronous Code&quot;.  This code provides the input <em>A</em> that
gets the ball rolling.</p>

<div style="text-align:center;"><img alt="Deferred object that some asynchronous code will call" src="defer-w-async.dot.png"/></div>

<p>Under normal circumstances, <em>C</em> simply falls off into oblivion; no other
code cares about it!</p>

<p>Now, suppose that the asynchronous code finishes its job and
calls the Deferred.  While processing this value,
<em>Callback 1</em> returns a <em>Deferred B</em> instead
of an actual <em>B</em>, indicating, &quot;No wait, the value isn't ready yet!&quot;</p>

<div style="text-align:center;"><img alt="Deferred object that some asynchronous code will call" src="defer-ret-defer.dot.png"/></div>

<p>We can't just pass <em>Deferred B</em> to <em>Callback 2</em>, since it's
expecting a <em>B</em>, not a deferred. How do we get <em>B</em> out of <em>Deferred B</em>?
Well, recall what <em>Deferred B</em> looks like:</p>

<div style="text-align:center;"><img alt="The deferred object that callback 1 returned." src="defer-b.dot.png"/></div>

<p>There are a few comments to be made about this deferred: first off, it's a fully formed
deferred object that some other asynchronous code, <em>Asynchronous Code for
B</em>, has promised to call back with a result.
However, this result in this example isn't actually <em>B</em>; it's
us <em>B''</em>.  You can imagine this as some precursor value for <em>B</em> that needs to go through
Callback 1' and Callback 2' before it becomes <em>B</em>.  We've used the prime symbol (') in order
to distinguish Callback 1 from Callback 1'; they are distinct and may be completely different
functions.</p>

<p>By now, the words &quot;chain&quot; and the arrow labeled <em>B</em> probably have given you some
idea how to reincorporate <em>Deferred B</em> into the original deferred.  Sure enough, we
simply plug it in.</p>

<div style="text-align:center;"><img alt="The deferred object that callback 1 returned." src="defer-new.dot.png"/></div>

<p>(We've omitted Callback 1 from the diagram for the interest of brevity; it
is now inaccessible and non-existent for the purposes of finishing processing.)
The evaluation proceeds as normal.  Note that any of the callbacks in our new chained
Deferred can return a deferred and repeat this process.</p>

<p>One last comment: something interesting has happened to the value that
comes out of the last callback: for <em>Deferred B</em>, it was actually used!
Chaining deferreds means that we care about the ultimate end result of our
callback chain.</p>

<h3>Dependencies<a name="auto9"/></h3>

<p>Well written, maintainable callbacks maintain &quot;contracts&quot; with respect to
their behavior.  Any given callback should have a well-defined value it takes
and a well-defined value that it returns.  This is good sense that applies
not only to callbacks but also to functions.</p>

<p>We've now added a slight twist to this, in that any callback can
return the value that it is contractually obligated to supply, or it
can <em>promise</em> to return to the value in the form of a Deferred. (Imagine
if you could get away doing this in real life!)  And, in the process of fulfilling
that promise, you discover you need to do another asynchronous request.  Something
has just happened: you're resolving a dependency chain.</p>

<p>[ here goes an example with actual running Twisted code in three steps.
Pictures of how the &quot;callback&quot; chain looks like as we discover more and
more dependencies should be supplied ]</p>

<h3>Looping<a name="auto10"/></h3>

<p>A common form of dependency is needing to perform the asynchronous
operation all over again.  The canonical example of this an HTTP
redirect: when the callback for a deferred from a page request is
returned, it could be the result, or it could be an empty body
with the <code>Location</code> HTTP header set, in which case
you simply perform the operation over again.</p>

<p>[ here is the HTTP redirect example.  It also should have pictures. ]</p>

<h3>Lambdas<a name="auto11"/></h3>

<p>We now take this opportunity to remind you that chaining deferreds
often results in the creation of lots of little functions to shuffle
the result of one operation to the next asynchronous function.  Sometimes
you can be clever and pass the asynchronous function itself as a callback,
but this only works if the next asynchronous function takes a single
parameter, and that parameter is the result of the previous computation.</p>

<p>In simple cases, you may want to use a lambda to move a parameter
around, or partially apply a function.  Suppose we have an asynchronous
function <code>send_message(value, type)</code>, and we know that
in our code type should equal <code>2</code>, then:</p>

<table class="compare">
    <tr>
        <th colspan="1" rowspan="1">Without lambdas</th>
        <th colspan="1" rowspan="1">With lambdas</th>
    </tr>
    <tr>
        <td colspan="1" rowspan="1"><pre class="python"><p class="py-linenumber">1
2
3
4
</p><span class="py-src-variable">d</span> = <span class="py-src-variable">asynchronous_operation</span>()
<span class="py-src-keyword">def</span> <span class="py-src-identifier">send_message_callback</span>(<span class="py-src-parameter">result</span>):
    <span class="py-src-keyword">return</span> <span class="py-src-variable">send_message</span>(<span class="py-src-variable">result</span>, <span class="py-src-number">2</span>)
<span class="py-src-variable">d</span>.<span class="py-src-variable">addCallback</span>(<span class="py-src-variable">send_message_callback</span>)
</pre></td>
        <td colspan="1" rowspan="1"><pre class="python"><p class="py-linenumber">1
2
</p><span class="py-src-variable">d</span> = <span class="py-src-variable">asynchronous_operation</span>()
<span class="py-src-variable">d</span>.<span class="py-src-variable">addCallback</span>(<span class="py-src-keyword">lambda</span> <span class="py-src-variable">x</span>: <span class="py-src-variable">send_message</span>(<span class="py-src-variable">x</span>, <span class="py-src-number">2</span>))
</pre></td>
    </tr>
</table>



<h2>Composing Deferreds<a name="auto12"/></h2>



<p>Chaining deferred dealt with sequential computation: each successive
asynchronous operation required the result of the previous computation
in order to run.  But we could have done this very easily synchronously:
asynchronous execution shines when we want to perform computations in
<em>parallel</em>.  But parallelizing computations results in some
questions: when is a parallel computation complete?  How do I treat
these parallel computations as a single unit?</p>

<p>The answer is <em>composition</em>, that is, we can combine deferreds
together into a single deferred.  As it turns out, Twisted has some
built-in facilities for doing this.</p>

<h3>The implementation of a DeferredList<a name="auto13"/></h3>

<p>Consider a Deferred that
would only fire after some other number of Deferreds fired.</p>

<pre class="python"><p class="py-linenumber">1
2
3
4
</p><span class="py-src-keyword">class</span> <span class="py-src-identifier">FireWhenAllFinish</span>(<span class="py-src-parameter">Deferred</span>):
    <span class="py-src-keyword">def</span> <span class="py-src-identifier">__init__</span>(<span class="py-src-parameter">self</span>, <span class="py-src-parameter">deferreds</span>):
        super(FireWhenAllFinish, self).__init__()
        <span class="py-src-variable">self</span>.<span class="py-src-variable">deferreds</span> = <span class="py-src-variable">deferreds</span>
</pre>

<p>We start off with a logical constructor for our class: a simple
list of the Deferred objects we want to finish before this Deferred
fires.  Recall that we need to setup callbacks in each Deferred in
<code>deferreds</code> to tell us when they've finished.  Thus:</p>

<pre class="python"><p class="py-linenumber"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
</p><span class="py-src-keyword">class</span> <span class="py-src-identifier">FireWhenAllFinish</span>(<span class="py-src-parameter">Deferred</span>):
    <span class="py-src-keyword">def</span> <span class="py-src-identifier">__init__</span>(<span class="py-src-parameter">self</span>, <span class="py-src-parameter">deferreds</span>):
        super(FireWhenAllFinish, self).__init__()
        <span class="py-src-variable">self</span>.<span class="py-src-variable">deferreds</span> = <span class="py-src-variable">deferreds</span>
        <span class="py-src-keyword">for</span> <span class="py-src-variable">d</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">self</span>.<span class="py-src-variable">deferreds</span>:
            <span class="py-src-variable">self</span>.<span class="py-src-variable">addCallbacks</span>(<span class="py-src-variable">self</span>.<span class="py-src-variable">_cbDeferred</span>, <span class="py-src-variable">self</span>.<span class="py-src-variable">_ebDeferred</span>)
            <span class="py-src-variable">self</span>.<span class="py-src-variable">addErrback</span>(<span class="py-src-variable">self</span>.<span class="py-src-variable">_ebDeferred</span>)
    <span class="py-src-keyword">def</span> <span class="py-src-identifier">_cbDeferred</span>(<span class="py-src-parameter">self</span>, <span class="py-src-parameter">result</span>):
        <span class="py-src-keyword">raise</span> <span class="py-src-variable">NotImplemented</span>
    <span class="py-src-keyword">def</span> <span class="py-src-identifier">_ebDeferred</span>(<span class="py-src-parameter">self</span>, <span class="py-src-parameter">failure</span>):
        <span class="py-src-keyword">raise</span> <span class="py-src-variable">NotImplemented</span>
</pre>

<p>Now, for the definition of <code>_cbDeferred</code>, after a little
thought, and the knowledge that <code>callback()</code> and
<code>errback()</code> are the
methods you can use to <em>fire</em> a deferred (it's what
<code>asynchronous_operation()</code> would have called behind
the veil), a relatively simple implementation comes to mind:</p>

<pre class="python"><p class="py-linenumber"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
</p><span class="py-src-keyword">class</span> <span class="py-src-identifier">FireWhenAllFinish</span>(<span class="py-src-parameter">Deferred</span>):
    <span class="py-src-keyword">def</span> <span class="py-src-identifier">__init__</span>(<span class="py-src-parameter">self</span>, <span class="py-src-parameter">deferreds</span>):
        super(FireWhenAllFinish, self).__init__()
        <span class="py-src-variable">self</span>.<span class="py-src-variable">deferreds</span> = <span class="py-src-variable">deferreds</span>
        <span class="py-src-variable">self</span>.<span class="py-src-variable">finishedCount</span> = <span class="py-src-number">0</span>
        <span class="py-src-keyword">if</span> <span class="py-src-keyword">not</span> <span class="py-src-variable">self</span>.<span class="py-src-variable">deferreds</span>:
            <span class="py-src-variable">self</span>.<span class="py-src-variable">callback</span>()
        <span class="py-src-keyword">for</span> <span class="py-src-variable">d</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">self</span>.<span class="py-src-variable">deferreds</span>:
            <span class="py-src-variable">self</span>.<span class="py-src-variable">addCallbacks</span>(<span class="py-src-variable">self</span>.<span class="py-src-variable">_cbDeferred</span>, <span class="py-src-variable">self</span>.<span class="py-src-variable">_ebDeferred</span>)
    <span class="py-src-keyword">def</span> <span class="py-src-identifier">_cbDeferred</span>(<span class="py-src-parameter">self</span>, <span class="py-src-parameter">result</span>):
        <span class="py-src-variable">self</span>.<span class="py-src-variable">finishedCount</span> += <span class="py-src-number">1</span>
        <span class="py-src-keyword">if</span> <span class="py-src-variable">self</span>.<span class="py-src-variable">finishedCount</span> == <span class="py-src-variable">len</span>(<span class="py-src-variable">self</span>.<span class="py-src-variable">deferreds</span>):
            <span class="py-src-variable">self</span>.<span class="py-src-variable">callback</span>()
    <span class="py-src-keyword">def</span> <span class="py-src-identifier">_ebDeferred</span>(<span class="py-src-parameter">self</span>, <span class="py-src-parameter">failure</span>):
        <span class="py-src-keyword">if</span> <span class="py-src-keyword">not</span> <span class="py-src-variable">self</span>.<span class="py-src-variable">called</span>: <span class="py-src-comment"># this property is True if callback()/errback() has already been called</span>
            <span class="py-src-variable">self</span>.<span class="py-src-variable">failed</span> = <span class="py-src-variable">True</span>
            <span class="py-src-variable">self</span>.<span class="py-src-variable">errback</span>()
</pre>

<p>There are two gotchas: the first is that if there were no
deferreds passed into this deferred, we should automatically fire
our callback; after all, we're not waiting on anything thing.
The second is that <code>callback()</code> and <code>errback()</code>
must only be called (between the two of them) once, so we manually
guard for this by checking if <code>self.called</code> is <code>False</code>
before making the errback call (why such a check is unnecessary for
callback call is left as an exercise for the reader.)</p>



<h3>Making your own deferreds<a name="auto14"/></h3>

<h3>Simple case: batons<a name="auto15"/></h3>

</div>

    <p><a href="index.html">Index</a></p>
    <span class="version">Version: </span>
  </body>
</html>
