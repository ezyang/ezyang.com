-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | In memory storage of deeply evaluated data structure
--   
--   This package provides a single data structure, called a Compact, which
--   holds a single haskell object in fully evaluated form. The invariant
--   is, no pointers live inside the struct that point outside it, which
--   ensures efficient garbage collection without ever reading the
--   structure contents (effectively, it works as a manually managed
--   "oldest generation" which is never freed until the whole is released).
--   Internally, the struct is stored a single contiguous block of memory,
--   which allows efficient serialization and deserialization of structs
--   for distributed computing.
@package compact
@version 1.0.0.0


-- | This module provides a data structure, called a Compact, for holding a
--   set of fully evaluated Haskell values in a consecutive block of
--   memory.
--   
--   As the data fully evaluated and pure (thus immutable), it maintains
--   the invariant that no memory reference exist from objects inside the
--   Compact to objects outside, thus allowing very fast garbage collection
--   (at the expense of increased memory usage, because the entire set of
--   object is kept alive if any object is alive).
--   
--   This is a private implementation detail of the package and should not
--   be imported directly
--   
--   <i>Since: 1.0.0</i>
module Data.Compact.Imp

-- | A pointer to an object that lives in a compact region.
data Compact a
[LargeCompact] :: Compact# -> a -> Compact a
[SmallCompact] :: a -> Compact a

-- | Returns the underlying object pointer of a compact pointer.
compactGetRoot :: Compact a -> a

-- | Resizes a compact region to a new size. Existing data is preserved.
compactResize :: Compact a -> Word -> IO ()

-- | Creates a "fake" compact region suitable for storing very small
--   objects, where actually trying to make them contiguous is not
--   profitable.
compactNewSmall :: a -> IO (Compact a)

-- | Tests if <tt>a</tt> lives in the compact region <tt>Compact b</tt>.
compactContains :: Compact b -> a -> Bool

-- | Tests if <tt>a</tt> is in compact normal form (i.e. is in any compact
--   region)
compactContainsAny :: a -> Bool
compactAppendEvaledInternal :: Compact# -> a -> Int# -> State# RealWorld -> (# State# RealWorld, Compact a #)
compactAppendOneInternal :: Compact b -> a -> IO (Compact a)

-- | A metadata structure which represents a compact region as a (list) of
--   pointers to memory regions (with their lengths), with a distinguished
--   pointer representing the root of the region. This structure is
--   transmitted out of band along with the actual contents of the regions.
data SerializedCompact a
[SerializedCompact] :: [(Ptr a, Word)] -> Ptr a -> SerializedCompact a
[serializedCompactGetBlockList] :: SerializedCompact a -> [(Ptr a, Word)]
[serializedCompactGetRoot] :: SerializedCompact a -> Ptr a
withCompactPtrsInternal :: NFData c => Compact a -> (SerializedCompact a -> IO c) -> IO c

-- | Given a <a>SerializedCompact</a> data structure, as well as a "fill
--   function" which loads data to the address 'Ptr b', import a compact
--   region into Haskell. We're parametrized over a fill function so that a
--   user either copy or mmap memory into the correct position (the user
--   does not generally know what an acceptable address to load the data
--   structure is.) Note that the values passed by 'Ptr b' may vary from
--   the pointers specified in <a>SerializedCompact</a>; if this is the
--   case, <a>compactImport</a> will fix up the pointers so they point to
--   the correct location.
compactImport :: SerializedCompact a -> (Ptr b -> Word -> IO ()) -> IO (Maybe (Compact a))

-- | Variant of <a>compactImport</a> that assumes that the data comes from
--   a source we trust. This runs faster but is less safe.
compactImportTrusted :: SerializedCompact a -> (Ptr b -> Word -> IO ()) -> IO (Maybe (Compact a))

-- | Easier to use version of <a>compactImport</a> which works on
--   Bytestrings.
compactImportByteStrings :: SerializedCompact a -> [ByteString] -> IO (Maybe (Compact a))

-- | Easier to use version of <a>compactImport</a> which works on
--   Bytestrings and assumes the input is trusted.
compactImportByteStringsTrusted :: SerializedCompact a -> [ByteString] -> IO (Maybe (Compact a))

-- | This enables symbol table support for compact regions, which means
--   that the compact region can be sent to another binary which is not
--   identical to our source binary. You must still call
--   <a>compactBuildSymbolTable</a> before sending.
compactInitForSymbols :: Compact a -> IO ()

-- | Call this prior to transmitting a compact region; this creates a
--   symbol table which can be used to fix up info tables at the receiving
--   end. (This symbol table is automatically transmitted with the rest of
--   the compact region.)
compactBuildSymbolTable :: Compact a -> IO ()


-- | This module provides a data structure, called a Compact, for holding a
--   set of fully evaluated Haskell values in a consecutive block of
--   memory.
--   
--   As the data fully evaluated and pure (thus immutable), it maintains
--   the invariant that no memory reference exist from objects inside the
--   Compact to objects outside, thus allowing very fast garbage collection
--   (at the expense of increased memory usage, because the entire set of
--   object is kept alive if any object is alive).
--   
--   This is similar to Data.Compact, but it supports incremental
--   evaluation into Compact structures.
--   
--   <i>Since: 1.0.0</i>
module Data.Compact.Incremental

-- | A pointer to an object that lives in a compact region.
data Compact a

-- | Returns the underlying object pointer of a compact pointer.
compactGetRoot :: Compact a -> a

-- | Resizes a compact region to a new size. Existing data is preserved.
compactResize :: Compact a -> Word -> IO ()

-- | Tests if <tt>a</tt> lives in the compact region <tt>Compact b</tt>.
compactContains :: Compact b -> a -> Bool

-- | Tests if <tt>a</tt> is in compact normal form (i.e. is in any compact
--   region)
compactContainsAny :: a -> Bool
compactNew :: Compactable a => Word -> a -> IO (Compact a)
compactNewAt :: Compactable a => Word -> Ptr b -> a -> IO (Compact a)

-- | Creates a "fake" compact region suitable for storing very small
--   objects, where actually trying to make them contiguous is not
--   profitable.
compactNewSmall :: a -> IO (Compact a)
compactAppendOne :: Compactable a => Compact b -> a -> IO (Compact a)
compactAppendRecursively :: Compactable a => Compact b -> a -> IO (Compact a)
compactAppendEvaled :: Compact b -> a -> IO (Compact a)
compactAppendSmall :: Compactable a => Compact b -> a -> IO (Compact a)
class Compactable a
compact :: Compactable a => Compact b -> a -> IO (Compact a)

-- | <a>defaultCompactNFData</a>: a default implementation for compact
--   suitable | for NFData instances
defaultCompactNFData :: NFData a => Compact b -> a -> IO (Compact a)

-- | A metadata structure which represents a compact region as a (list) of
--   pointers to memory regions (with their lengths), with a distinguished
--   pointer representing the root of the region. This structure is
--   transmitted out of band along with the actual contents of the regions.
data SerializedCompact a
[SerializedCompact] :: [(Ptr a, Word)] -> Ptr a -> SerializedCompact a
[serializedCompactGetBlockList] :: SerializedCompact a -> [(Ptr a, Word)]
[serializedCompactGetRoot] :: SerializedCompact a -> Ptr a
withCompactPtrs :: (Compactable a, NFData c) => Compact a -> (SerializedCompact a -> IO c) -> IO c

-- | Given a <a>SerializedCompact</a> data structure, as well as a "fill
--   function" which loads data to the address 'Ptr b', import a compact
--   region into Haskell. We're parametrized over a fill function so that a
--   user either copy or mmap memory into the correct position (the user
--   does not generally know what an acceptable address to load the data
--   structure is.) Note that the values passed by 'Ptr b' may vary from
--   the pointers specified in <a>SerializedCompact</a>; if this is the
--   case, <a>compactImport</a> will fix up the pointers so they point to
--   the correct location.
compactImport :: SerializedCompact a -> (Ptr b -> Word -> IO ()) -> IO (Maybe (Compact a))

-- | Variant of <a>compactImport</a> that assumes that the data comes from
--   a source we trust. This runs faster but is less safe.
compactImportTrusted :: SerializedCompact a -> (Ptr b -> Word -> IO ()) -> IO (Maybe (Compact a))

-- | Easier to use version of <a>compactImport</a> which works on
--   Bytestrings.
compactImportByteStrings :: SerializedCompact a -> [ByteString] -> IO (Maybe (Compact a))

-- | Easier to use version of <a>compactImport</a> which works on
--   Bytestrings and assumes the input is trusted.
compactImportByteStringsTrusted :: SerializedCompact a -> [ByteString] -> IO (Maybe (Compact a))

-- | This enables symbol table support for compact regions, which means
--   that the compact region can be sent to another binary which is not
--   identical to our source binary. You must still call
--   <a>compactBuildSymbolTable</a> before sending.
compactInitForSymbols :: Compact a -> IO ()

-- | Call this prior to transmitting a compact region; this creates a
--   symbol table which can be used to fix up info tables at the receiving
--   end. (This symbol table is automatically transmitted with the rest of
--   the compact region.)
compactBuildSymbolTable :: Compact a -> IO ()
instance Compactable a => Compactable [a]
instance Compactable ()
instance (Compactable a, Compactable b) => Compactable (a, b)
instance (Compactable a, Compactable b, Compactable c) => Compactable (a, b, c)
instance (Compactable a, Compactable b, Compactable c, Compactable d) => Compactable (a, b, c, d)
instance (Compactable a, Compactable b, Compactable c, Compactable d, Compactable e) => Compactable (a, b, c, d, e)
instance Compactable a => Compactable (Maybe a)
instance (Compactable a, Compactable b) => Compactable (Either a b)
instance Compactable Int
instance Compactable Char
instance Compactable Float
instance Compactable Word
instance Compactable Integer
instance Compactable Double


-- | This module provides a data structure, called a Compact, for holding a
--   set of fully evaluated Haskell values in a consecutive block of
--   memory.
--   
--   As the data fully evaluated and pure (thus immutable), it maintains
--   the invariant that no memory reference exist from objects inside the
--   Compact to objects outside, thus allowing very fast garbage collection
--   (at the expense of increased memory usage, because the entire set of
--   object is kept alive if any object is alive).
--   
--   This module provides a Monad for executing code in the context of a
--   compact, so that all values threaded through the monad are stored in
--   the compact.
--   
--   <i>Since: 1.0.0</i>
module Data.Compact.Monad
data CompactM b a
runCompactM :: Compactable b => CompactM b a -> Compact b -> IO (Compact a)
compactPut :: Compactable a => a -> CompactM b a
instance Monad (CompactM b)
instance Applicative (CompactM b)
instance Functor (CompactM b)


-- | This module provides a data structure, called a Compact, for holding a
--   set of fully evaluated Haskell values in a consecutive block of
--   memory.
--   
--   As the data fully evaluated and pure (thus immutable), it maintains
--   the invariant that no memory reference exist from objects inside the
--   Compact to objects outside, thus allowing very fast garbage collection
--   (at the expense of increased memory usage, because the entire set of
--   object is kept alive if any object is alive).
--   
--   <i>Since: 1.0.0</i>
module Data.Compact

-- | A pointer to an object that lives in a compact region.
data Compact a

-- | Returns the underlying object pointer of a compact pointer.
compactGetRoot :: Compact a -> a

-- | Tests if <tt>a</tt> lives in the compact region <tt>Compact b</tt>.
compactContains :: Compact b -> a -> Bool

-- | Tests if <tt>a</tt> is in compact normal form (i.e. is in any compact
--   region)
compactContainsAny :: a -> Bool

-- | Creates a new compact region of some size, initially containing
--   <tt>a</tt>.
compactNew :: NFData a => Word -> a -> IO (Compact a)

-- | Create a new compact region at a specified address (if possible).
compactNewAt :: NFData a => Word -> Ptr b -> a -> IO (Compact a)

-- | Creates a new compact region of some size, initially containing
--   <tt>a</tt>, without preserving sharing in <tt>a</tt>. This variant is
--   faster than <a>compactNew</a>.
compactNewNoShare :: NFData a => Word -> a -> IO (Compact a)

-- | Create a new compact region at a specified address (if possible),
--   without preserving sharing (this is faster than <a>compactNewAt</a>).
compactNewNoShareAt :: NFData a => Word -> Ptr b -> a -> IO (Compact a)

-- | Creates a "fake" compact region suitable for storing very small
--   objects, where actually trying to make them contiguous is not
--   profitable.
compactNewSmall :: a -> IO (Compact a)

-- | Appends <tt>a</tt> into the compact region pointed to by <tt>Compact
--   b</tt>. This function preserves sharing. (Note: unlike in the paper,
--   we incorrectly have the type signature <a>NFData</a> here. This is for
--   convenience, so users don't have to write a lot of type class
--   instances. We will error at runtime if you pass a type which is not
--   serializable.)
compactAppend :: NFData a => Compact b -> a -> IO (Compact a)

-- | Appends a "small object" to a compact region. If the region in
--   question is small, we will continue to defer actually generating a
--   proper contiguous region.
compactAppendSmall :: NFData a => Compact b -> a -> IO (Compact a)

-- | Appends <tt>a</tt> into a compact region pointed to by <tt>Compact
--   b</tt>. Any sharing that is not already in a compact region is not
--   preserved; however, this version is a bit faster than
--   <a>compactAppend</a>.
compactAppendNoShare :: NFData a => Compact b -> a -> IO (Compact a)

-- | Resizes a compact region to a new size. Existing data is preserved.
compactResize :: Compact a -> Word -> IO ()

-- | A metadata structure which represents a compact region as a (list) of
--   pointers to memory regions (with their lengths), with a distinguished
--   pointer representing the root of the region. This structure is
--   transmitted out of band along with the actual contents of the regions.
data SerializedCompact a
[SerializedCompact] :: [(Ptr a, Word)] -> Ptr a -> SerializedCompact a
[serializedCompactGetBlockList] :: SerializedCompact a -> [(Ptr a, Word)]
[serializedCompactGetRoot] :: SerializedCompact a -> Ptr a

-- | Given a compact region, run <tt>func</tt> with the metadata structure
--   <a>SerializedCompact</a>. Useful for transmitting compact regions.
withCompactPtrs :: (NFData a, NFData c) => Compact a -> (SerializedCompact a -> IO c) -> IO c

-- | Given a <a>SerializedCompact</a> data structure, as well as a "fill
--   function" which loads data to the address 'Ptr b', import a compact
--   region into Haskell. We're parametrized over a fill function so that a
--   user either copy or mmap memory into the correct position (the user
--   does not generally know what an acceptable address to load the data
--   structure is.) Note that the values passed by 'Ptr b' may vary from
--   the pointers specified in <a>SerializedCompact</a>; if this is the
--   case, <a>compactImport</a> will fix up the pointers so they point to
--   the correct location.
compactImport :: SerializedCompact a -> (Ptr b -> Word -> IO ()) -> IO (Maybe (Compact a))

-- | Variant of <a>compactImport</a> that assumes that the data comes from
--   a source we trust. This runs faster but is less safe.
compactImportTrusted :: SerializedCompact a -> (Ptr b -> Word -> IO ()) -> IO (Maybe (Compact a))

-- | Easier to use version of <a>compactImport</a> which works on
--   Bytestrings.
compactImportByteStrings :: SerializedCompact a -> [ByteString] -> IO (Maybe (Compact a))

-- | Easier to use version of <a>compactImport</a> which works on
--   Bytestrings and assumes the input is trusted.
compactImportByteStringsTrusted :: SerializedCompact a -> [ByteString] -> IO (Maybe (Compact a))

-- | This enables symbol table support for compact regions, which means
--   that the compact region can be sent to another binary which is not
--   identical to our source binary. You must still call
--   <a>compactBuildSymbolTable</a> before sending.
compactInitForSymbols :: Compact a -> IO ()

-- | Call this prior to transmitting a compact region; this creates a
--   symbol table which can be used to fix up info tables at the receiving
--   end. (This symbol table is automatically transmitted with the rest of
--   the compact region.)
compactBuildSymbolTable :: Compact a -> IO ()
