The Computer Security Foundations Symposium (CSF 2013) program committee is
sorry to inform you that your paper 10 was rejected, and will not appear
in the conference.
19 papers were accepted out of 73 submissions.

Reviews on your paper are appended to this email.

On behalf of the program committee I would like to thank you for your submission.

Sincerely,
  VÃ©ronique Cortier & Anupam Datta
  CSF 2013 PC Chairs


----------------------- REVIEW 1 ---------------------
PAPER: 10
TITLE: Eliminating Cache-Based Timing Attacks with Instruction-Based Scheduling
AUTHORS: Pablo Buiras, Amit Levy, Alejandro Russo, David Mazieres, Deian Stefan, David Terei and Edward Yang

OVERALL EVALUATION: -1 (weak reject)

----------- REVIEW -----------
The paper deals with the problem of covert channels that stem from
features of the hardware platform in otherwise IFC controlled
concurrent systems (in particular the Hails platform).

The key issue is that formal approaches to information-flow in
concurrent systems are (often implicitly) based on instruction-level
schedulers, owned to the fact that those can be easily expressed in
terms of programming language semantics. If a real-world
implementation of corresponding systems bases scheduling decisions on
real time rather than on the number of instructions, formal security
guarantees break down because their proof is based on invalid
assumptions.

The contributions of this paper are a) an attack implementing a simple
cache-based covert channel that illustrates this fact and b) the
implementation and evaluation of a practical instruction-based
scheduler in the Haskell runtime.

The paper further claims as a technical contributions the formal proof
of noninterference of the system from [61] w.r.t an instruction-based
scheduler. But what the authors technically do is to first augment the
evaluation rule of threads by a parameter k capturing the number of
clock cycles consumed -- and then ignore the k in the scheduling rule
to emphasize that the scheduler is an instruction-level scheduler. In
the end they obtain essentially the same semantics/proofs as in
[61]. This is just blowing smoke and not a contribution.

I am generally impressed by the authors' line of work on Hails because
it is a fine example on how systems research and formal approaches can
fruitfully connect. The paper at hand closes and important gap in
these systems, but it does not contribute sufficient conceptual
novelty to justify acceptance at CSF.

Detailled comments: 

- Can your approach exclude access-based cache attacks?  (I.e. attacks
where a thread learns information about the final cache state of a
preempted thread by timing its own memory accesses.)

-The statement of Theorem 1 raises a red flag. \forall\exists-based
notions of noninterference are often not preserved under refinement
(the witness for existence may be refined away). This is not a problem
in this paper because the system is deterministic! You may want to
emphasise this important fact somewhere around (or in) Theorem 1.

- Personally I dislike the term "refinement attack", although it is
often used in the literature, because there is no actual attack. It is
probably more accurate to say that possibilistic noninterference does
(in general) not imply meaningful security guarantees.

- Related work: The paper gives a comprehensive overview of
information-flow approaches to concurrency, but it doesn't really
establish connections apart from the statement that they are all
susceptible to cache attacks -- which is unsurprising because they
abstract from caches in the first place.  Instead, I think it would be
more interesting to discuss approaches that actually *do* consider
caches, such as [8], Hedin et al [ENTCS '05], Kopf et al [CAV '12], or
Kim et al [Usenix Security '12].

- Having the motivation is Section 2 is strange. Why not use the intro
  for motivational purposes?

- Sect IV: "Internal timing attacks are reintroduced". This is a
  strange way to see things. They were never gone, we just prove their
  absence on unsound models.

- The paper is somewhat ambiguous about the use of partitioned caches.
  In the introduction the authors claim that they are not yet
  practical, whereas in Section VIII C they are sold as the way to go
  to achieve parallelism.


----------------------- REVIEW 2 ---------------------
PAPER: 10
TITLE: Eliminating Cache-Based Timing Attacks with Instruction-Based Scheduling
AUTHORS: Pablo Buiras, Amit Levy, Alejandro Russo, David Mazieres, Deian Stefan, David Terei and Edward Yang

OVERALL EVALUATION: -1 (weak reject)

----------- REVIEW -----------
This paper discusses practical cache-based timing attacks on (real) Information Flow Control (IFC) systems. The attacks consists of a malicious user loading code that intensively use cache depending on high level data, generating a timing covert channel towards the low level. Authors discuss existing solutions to the problem and propose a new one based on instruction-based scheduling. The idea is to switch to a new process when a certain amount of instructions have been executed, independently of the execution time. This clearly prevents the above attack. A previous formal model is extended to include the new solution and a security theorem is given.

This is a very well written paper and is totally in the scope of CSF. There are however some issues that weaken it: (1) the foundational aspects are not very surprising and somehow expected; proofs are not included in the appendix so it is impossible to evaluate technical soundness (2) the proposed solution does not scale to multi-core processors. This is a big limitation as modern architecture are in fact multi-core; (3) more importantly, I'm not convinced that the proposed scheduling is realistic. Basing context switch on the number of instruction would penalize processes that heavily use cache when executed together with processes with poor locality. Processes using cache will end up using a much smaller time-slot (as their instructions exploit cache and run much faster) than the ones that do not use cache much. In fact, the benefit of the cache would be unfairly spread among all processes independently of their locality. Authors state that they measured the performance of the proposed scheduler but they do not mention this problem. I guess the adopted banchmark missed the above discussed experiment.

Detailed comments:

page 2: 'when execution is confined to a single CPU.' how realistic is this assumption?

page 2: 'Without considering the cache, Hails apps cannot leak in- formation. '. I would say 'to the best of your knowledge'

page 5: 'be cause by the secret' -> 'be caused by the secret'

page 6, nofib: is this specifically intended for concurrent executions? You should consider executing processes that heavily use the cache together with ones that do not exploit cache to see how performance is affected

page 8: 'with our formalisation of CPU cache is given below' remove 'is'


----------------------- REVIEW 3 ---------------------
PAPER: 10
TITLE: Eliminating Cache-Based Timing Attacks with Instruction-Based Scheduling
AUTHORS: Pablo Buiras, Amit Levy, Alejandro Russo, David Mazieres, Deian Stefan, David Terei and Edward Yang

OVERALL EVALUATION: 1 (weak accept)

----------- REVIEW -----------
The paper attacks the problem of covert channels created by cache usage in multi-threaded programs. 
The paper observes that the use of the cache by one thread can affect the execution time of another thread, 
and that therefore, if the scheduling policy is based only on time slots, the result of the program may depend on the 
use of the cache, which in turns may depend on the value of the secrets. 

The proposal by the authors is to simply base the scheduling policy on the number of instructions rather than on the execution time.  In this way, even though the use of the cache will continue to affect the duration of an instruction, this will not be visible at the level of the observations. 

The authors have then experimented with various benchmarks, to study whether their method causes a degradation in performance, and how much. It turns out that by tuning the instruction budget carefully, the degradation is minimal. 

Then the authors prove that system  an instruction-based scheduler, and in the presence of a cache, satisfy termination-sensitive non-interference.  The proof seems a simple re-adaptation of the proof by [61].

Pros: 
- The paper attacks an important problem
- It  is competent and well written 
                                                                                                                                                                                                                                        
Cons: 
- The paper may be slightly out of scope, since there is no "foundational" contribution in it 
- The proposed approach is only developed for the deterministic case, i.e. not for the case in which the threads can run in parallell on different cores. This is unfortunate, since the typical context for using threads is that of multi-core systems

