We are pleased to inform you that your submission to ESORICS 2013, "Eliminating Cache-Based Timing Attacks with Instruction-Based Scheduling", has been accepted.  The conference was extremely competitive this year, with 43 papers out of 242 being accepted, an acceptance rate of around 18%.

The reviews for your paper are appended to this email. Please ensure that you address the reviewers' comments when preparing your camera-ready copy. The deadline for the submission of camera-ready copy is 21 June. Further details about the preparation and submission of camera-ready copy will follow shortly.

At least one author is expected to register for the conference (at the full delegate rate) and present the paper.  Further instructions concering registration are available at http://esorics2013.isg.rhul.ac.uk/registration/.

Best wishes


Jason Crampton & Sushil Jajodia
Programme Co-chairs


----------------------- REVIEW 1 ---------------------
PAPER: 247
TITLE: Eliminating Cache-Based Timing Attacks with Instruction-Based Scheduling
AUTHORS: Deian Stefan, Pablo Buiras, Edward Yang, Amit Levy, David Terei, Alejandro Russo and David Mazieres


----------- REVIEW -----------
This paper uses performance counters to control thread scheduling in a way that ensures that an information-leak channel 
cannot be established due to cache timing effects.  This approach is intuitive and will work as the authors described.  

The use of "safe to context switch" markers inserted into the code to avoid context switching at inopportune moments is 
a clever addition that will work in a managed environment such as the one the authors target.  The mechanism precludes 
simple use of profiling tools while it is in use (because performance counters are limited in systems), however, this is 
unlikely to be a real problem because the scheduler can be reverted to its "original" for the time of profiling.

=46rom a systems perspective, this work is kind of obvious up front that it will work, and it's just a matter of picking 
a system and implementing the technique (which the authors do).

Lets see it, why not.


----------------------- REVIEW 2 ---------------------
PAPER: 247
TITLE: Eliminating Cache-Based Timing Attacks with Instruction-Based Scheduling
AUTHORS: Deian Stefan, Pablo Buiras, Edward Yang, Amit Levy, David Terei, Alejandro Russo and David Mazieres


----------- REVIEW -----------
This paper describes extensions to the Hails web application framework built
on top of the LIO information flow control system and written in Haskell.
While LIO eliminates internal timing covert channels, the cache can still
form a covert channel. This work shows that such an attack is possible, and
provides a countermeasure to this covert channel on a single CPU platform by
using the performance measuring units on Intel and AMD processors to count
the number of instructions executed per execution context and switching
based on these values rather than on time quanta; importantly, no flushing
of the cache is required. A performance evaluation shows that changing to
instruction-based scheduling adds at most a 1% overhead to runtime compared
to the Haskell timing-based scheduler. Cache-aware reduction rules using the
instruction-based scheduler are also presented.

This is very strong work that provides an important new result in how to
close covert channels that can be caused through caches. Fixing the
scheduler to specific lengths is something that was also considered recently
in the seL4 microkernel as discussed in the Oakland 2013 paper by Murray et
al. ("seL4: from General Purpose to a Proof of Information Flow
Enforcement") though even in this work the authors acknowledge covert
channels are a possibility, making this work even more impressive. 

There was a strong blend of systems and theory work in this paper, with some
technical contributions through exploitation of PMUs to allow for
instruction-based scheduling to the formal semantics and subsequent proofs,
reflected in the extended technical report. 

The domain is somewhat specialized given the Haskell runtime and the
evaluation reflects this, as the limited increase in runtime by adopting a
new scheduling discipline is a byproduct of the relatively poor data locality
shown in functional programs adopting lazy evaluation. One wonders what the
effects would be were this implemented in a more performant environment. As
the authors acknowledge, handling multiprocessing quickly becomes
complicated as well. However, this is an important and interesting result
that represents a new way of attacking the persistent and pernicious covert
channel problem.


----------------------- REVIEW 3 ---------------------
PAPER: 247
TITLE: Eliminating Cache-Based Timing Attacks with Instruction-Based Scheduling
AUTHORS: Deian Stefan, Pablo Buiras, Edward Yang, Amit Levy, David Terei, Alejandro Russo and David Mazieres


----------- REVIEW -----------
The paper proposes and implements a simple effective idea for
eliminating internal timing leaks, by scheduling threads depending on
the (cache-independent) number of instructions they have executed,
rather than the (cache-dependent) time it took to execute them.

Although the existence of this side channel and the presented attack
are well-known, the use of hardware instruction counters is new, and
the implementation for Haskell/LIO and its experimental evaluation are
thorough.

The paper is well written. 

Its main weakness is that "solving" the internal timing channel
problem in isolation is not clearly useful. For instance, I am curious
whether instruction-based scheduling could actually amplify wall-clock
timing attacks, by making some threads noticeably slower when all
their memory accesses are cache misses... This would be worth
discussing.

page 1, not sure what you mean by "ripe application"; is it actually used?

4.3 please extend the discussion of I/O. 

Section 6 is disappointing. It is informally clear that it generalizes
[60], and I am not sure it is worth giving those details on the
semantics without a theorem statement.

Section 7, the "Scheduler..." argument is unclear. 

Section 8: single steps should be single step; Kopft should be K\"opf.
