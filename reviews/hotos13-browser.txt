                           HotOS XIV Review #16A
                 Updated Tuesday 15 Jan 2013 3:08:50pm PST
---------------------------------------------------------------------------
               Paper #16: Toward Principled Browser Security
---------------------------------------------------------------------------

                      Overall merit: 3. Weak accept - The problems are not
                                        fatal
                            Hotness: 2. Incremental
                         Pliability: 3. Proposal / speculation / analysis /
                                        preliminary experiment only. Lots
                                        of good questions.
                 Reviewer expertise: 3. Knowledgeable

                         ===== Paper summary =====

This paper argues that information flow control mechanisms can better
solve the tension between isolation and sharing in web browsers than
ad-hoc security policies like the same-origin policy.  The paper gives
an ultra-brief overview of IFC, then spends a few pages describing how
IFC maps to SOP.  Next, paper shows that IFC can also support CORS and
CSP, two browser enhancements that refine/extend SOP, and defend
against browser history exfiltration.  Finally, the paper discusses
other benefits of IFC for topics like including untrusted javascript
and browser extensions.

                      ===== Comments for author =====

On one hand, this paper is surely right: browser security policies and
mechanisms are ad-hoc, we have suffered as a result, and IFC is a
natural, great fit for the class of problems that SOP, CORS, CSP,
etc. try to solve.  Better, the paper is fairly convincing (though
necessarily brief) at mapping SOP to IFC policies and showing that
they can be subsumed, so this is a practical idea...it's just a "small
matter" of reimplementing or retrofitting browsers.

On the other hand, once you say "IFC and browsers," most of the
content of this paper seems straightforward...I felt like it didn't
teach me enough.  As well, I've heard the idea that browsers and
information flow control ought to be married before, though to be
fair, I can't point to a published paper that says precisely what this
paper proposes.  Somehow, I wanted more insight than the relatively
straightforward mapping of SOP/etc. to IFC constructs.

Maybe what I was looking for was additional insight into how we can
evolve the web and web browsers once IFC is in place.  The "we can
include untrusted JavaScript" is a hint of this -- a powerful example.
What else can we do?  What happens if both browsers and servers
support IFC?

Something else that would help is some digging into existing browser
architectures and source code to argue that there is a path to get
them there from here.  Do we need to complete reimplement browsers,
JavaScript engines, etc., adopt these ideas?  Or, is there a more
incremental retrofit that's possible? 

On the plus side, I'd like to hear the discussion that would take
place if this paper is accepted.

===========================================================================
                           HotOS XIV Review #16B
                 Updated Sunday 17 Feb 2013 11:28:25pm PST
---------------------------------------------------------------------------
               Paper #16: Toward Principled Browser Security
---------------------------------------------------------------------------

                      Overall merit: 4. Accept - This is a good paper and
                                        should probably be accepted
                            Hotness: 3. Hot-ish
                         Pliability: 3. Proposal / speculation / analysis /
                                        preliminary experiment only. Lots
                                        of good questions.
                 Reviewer expertise: 2. Some familiarity

                         ===== Paper summary =====

This paper explores the eternal "flexibility vs. security" conundrum in
the context of web browsers handling content and web apps. It proposes
the use of information flow control primitives as an all-encompassing
language for describing security policies in this context. The authors
show how the label lattice in IFC along with the declassification
operation can be used to expressed common policies that exist today, as
well as further policies that may be customized to in-browser web apps.

                      ===== Comments for author =====

The proposal of using IFC as a language for specifying security policies
is new to me, though I don't follow this area; it sounds like a clean,
elegant idea, modulo the practicality of implementing it efficiently. In
fact, the paper says absolutely nothing about how this might be
implemented in a real browser.

The granularity at which the policy is to be enforced now becomes
arbitrarily fine (byte level). The paper does not touch upon the
implications this has on the implementation (in terms of performance,
reliability, ...)?

I liked the argument made for wide applicability. But it would have been
nice to see a more principled discussion of the completeness of this
IFC-based language: Can all policies be expressed with it? Does it
impose undue restrictions on what can be formulated? (restrictions
themselves are not bad, SOP itself is a restriction, but I cannot tell
whether IFC introduces a potentially showstopper-type of problem)

It's nice that web apps can define custom policies. It's unclear though
who exactly has the write to define these policies, and whom can these
policies affect? Could a third-party app redefine the policies that are
in effect inside a browser? The paper seems to imply yes, but surely the
authors do not believe that. How does one reason about conflicting
policies?

I found the example involving reading a browser's history by exploiting
the CSS ":visited" selector value confusing. The authors seem to be
implying that, in an IFC-based policy, labeling the :visited information
<canRead=user://> would make the leak explicit (which I agree), but then
they turn around and say that declassification is not safe, so it
shouldn't be used, and getComputedStyle() should fail. Is this
advocating that the IFC-based language for expressing policies not allow
such explicit leaks, or is this just expressing the authors' opinion on
how the language should or should not be used?

The writing is annoyingly sloppy, almost enough to make me downgrade my
score. The paper often says the exact opposite of what it should (such
as swapping hostnames when explaining flows, mixing up operators, etc.).
Authors cut the conclusions and tried to jam into the 5 pages more than
was due (in other words, making us read more about this topic than we
should have); one could easily have trimmed Section 3 to accomplish
this.

===========================================================================
                           HotOS XIV Review #16C
                 Updated Tuesday 19 Feb 2013 3:49:35pm PST
---------------------------------------------------------------------------
               Paper #16: Toward Principled Browser Security
---------------------------------------------------------------------------

                      Overall merit: 3. Weak accept - The problems are not
                                        fatal
                            Hotness: 1. Not hot
                         Pliability: 2. Some results reported. An
                                        exploration of the space around a
                                        design the authors are already
                                        leaning towards.
                 Reviewer expertise: 2. Some familiarity

                         ===== Paper summary =====

The authors describe how Web browsers' security policies can be
expressed using information flow control (IFC), and argue that
implementing it that way---i.e., using formal IFC specification and
enforcement---would lead to a more secure browsing experience.

                      ===== Comments for author =====

In many ways, this paper is unsurprising.  IFC is the power tool of
security: most useful policies can indeed be expressed in a suitably
nuanced IFC framework.  The catch, of course, is whether the IFC system
can be implemented in an efficient fashion, and, critically, whether
programmers can be trusted to understand their needs and the formalism
well enough to provide accurate specifications for the framework to
enforce.  Indeed, the authors are not the first to make this
observation: the FlowFox work from CCS applies IFC to the browser.  This
manuscript simply argues for taking the approach to its logical
conclusion and implementing the entire set of browser security
policies---as opposed to those focused on scripting---through IFC
machinery.

Section 4 enumerates a number of potential benefits of IFC for web apps,
but it seems to presume that the authors of these apps know precisely
how to describe the IFC control they desire.  Clearly they can always
test to make sure the encoded policy is not too strict (it won't work
properly if so), but there doesn't seem to be an obvious way for them to
test whether or not the policy is too loose, which seems likely to lead
to a scenario where authors have a small handful of "default policies"
that they (think they) understand, and to just blindly apply one or more
of those to each app until it works, rather than being thoughtful and
constructing the precise policy for each use in a new application.

As a non-expert, I would have greatly appreciated a related work section
that explicitly compared the approach being advocated to that provided
by seemingly similar systems, some of which have been built by a subset
of the authors.  For example, how does his compare/extend/contrast with
Hails?

===========================================================================
                           HotOS XIV Review #16D
                 Updated Sunday 3 Mar 2013 11:55:56am PST
---------------------------------------------------------------------------
               Paper #16: Toward Principled Browser Security
---------------------------------------------------------------------------

                      Overall merit: 4. Accept - This is a good paper and
                                        should probably be accepted
                            Hotness: 3. Hot-ish
                         Pliability: 3. Proposal / speculation / analysis /
                                        preliminary experiment only. Lots
                                        of good questions.
                 Reviewer expertise: 2. Some familiarity

                         ===== Paper summary =====

The authors propose that a browser should be designed using information-flow
control (IFC).  This would allow the simple expression of a variety of
security policies, generating assurance that the policies were not undermined
by the behavior of any aspect of the browser's operation.  It would also
demonstrate to the browser designer the risks of various policy and
implementation choices, as it would readily demonstrate how information could
flow somewhere unexpected.  To demonstrate the flexibility of IFC, the authors
show how it can be used to express four examples of browser policies currently
in use or proposed.

                      ===== Comments for author =====

I'm intrigued by your idea of building a browser using information-flow
control so that policies can be simply expressed and their enforcement can be
ensured.  I'm not convinced it's doable, since I think there will likely
always be policies the community wants to express that can't be easily
expressed in IFC.  However, I'd like to see you try, as it seems like you have
some ideas that might turn into surprisingly effective solutions.
Furthermore, even if you don't succeed at expressing all policies everyone
wants, perhaps your architecture will serve as an inspiration to restrict the
set of policies to ones that can actually be enforced with IFC.

Your efforts to express the same-origin policy (SOP) as an IFC policy are
heroic.  However, SOP is simply not a good match for IFC.  It evolved too
organically, with the assumption of an arbitrarily complex browser
implementation to enforce it.  For instance, the SOP specifies how information
can flow based on how it will be used, such as images and scripts.  I applaud
your attempts to enforce these aspects in IFC through declassification, but
this is really just a hack.  Yes, you can make anything fit into IFC if you
include arbitrary declassifier and endorsement code, and allow that code to
fit in at arbitrary points, but that doesn't mean everything is a great fit
for IFC.  The benefit of IFC is it provides assurance of the absence of
incorrect flows of information.  But if you have to pile on tons of extra
trusted code external to the IFC-enforcement system, snaking its way
throughout your browser, it undermines the trustworthiness of any resulting
conclusions.

Your example in 3.4 gives a good example of my point.  It will become clear
that getComputedStyle() can't be used since it potentially leaks browser
history information via visited-link information.  However, IFC will go
further than this.  Because the visited-link style is part of the rendered
output, the browser history has to be provided to the renderer.  And then the
renderer's output will be entirely tainted by this information, and any call
that could potentially see any information about the rendered output of any
part of the page will be blocked.  You'll have to make some compromise like
making the renderer a trusted declassifier, but then you'll lose a lot of the
leak-finding power of your approach.  In particular, you won't see the fact
that getComputedStyle() can't be used.

I think, though, that you know this problem as well as I do, and there's a
hidden message you're trying to convey.  Wink, wink. :-) What you really plan
to do, I imagine, is build the IFC browser with the convoluted SOP expression
as (yet another) demonstration of just how hopelessly elaborate SOP is.  Where
your browser will really shine is in the enforcement of *other* policies that
are a better fit.  And, with luck, some day the world will see things more
clearly, partly with the benefit of your system, and embrace such alternate
policies.

Minor points: (1) Your author list is missing affiliations. I guess you were
having trouble fitting in five pages? You'll need to fix this for the final
version. (2) Please provide more background to understand what you mean by
"preflight setup" when you use this phrase. I wasn't familiar with it. (3)
There's a typo in the second paragraph of 3.2.  It says https://b.com OR
https://b.com but the first should be a.com.

===========================================================================
                           HotOS XIV Review #16E
                 Updated Sunday 10 Mar 2013 7:28:44pm PDT
---------------------------------------------------------------------------
               Paper #16: Toward Principled Browser Security
---------------------------------------------------------------------------

                      Overall merit: 2. Weak reject  - Probably a reject,
                                        but could be convinced otherwise
                            Hotness: 2. Incremental
                         Pliability: 3. Proposal / speculation / analysis /
                                        preliminary experiment only. Lots
                                        of good questions.
                 Reviewer expertise: 2. Some familiarity

                         ===== Paper summary =====

This paper makes a case for writing browsers that strictly enforce
decentralized information flow control. The authors argue that many of
today’s browser security policies, such as Single-Origin Policy, and
Cross-Origin Resource Sharing, can be straightforwardly expressed in
terms of DIFC with strategic use (by the trusted browser) of
declassification. The authors provide several examples to justify their
claim, and proceed to explain how web applications themselves can
benefit from such a DIFC browser infrastructure to give app developers a
stronger environment to develop for.

                      ===== Comments for author =====

This paper is not very well written. The language is almost uniformly
poor, there are disturbingly many typos, several examples are botched
(as far as I can tell) due to poor proof reading, and many concepts are
used before they are defined, or are never defined at all. (The last bit
is rather ironic for a security paper)

On its main points, the paper does make sense. The authors did convince
me that existing browser security policies are information-flow
policies, and can be expressed, with a bit of tricky declassification
glue logic, in terms of labels.

That was a worthwhile insight, but I’m not sure it was enough of a
contribution to merit publication, however. It covered possibility, but
not tractability. The authors didn’t talk about the implications of
rewriting today’s browsers---bursting with features---as DIFC systems.
Would the rewrite be a strictly positive change? Anything that wouldn’t
be quite as easy (or that wouldn’t perform well)? Overall, the paper
reads a bit like a case study for DIFC in the browser, and gave me
little else.
 


Editorial

What are CORS and CSP? Spell out before first use.

The introduction confused me somewhat with respect to what we trust
developers to do. It sounds like a developer should be able to
extend/otherwise modify the browser’s policy to suit his needs. That
doesn’t sound safe, in the general case. Would it make more sense to say
that the browser (or the end user) decides on a browser policy (e.g.,
SOP or one of the others) and, to the extent possible, developers can
*parametrize* that policy for their applications (as with CSRF)? I
certainly wouldn’t want a developer to turn off SOP unilaterally on my
browser.

It would be helpful to point out how related work that focused on
scripting is lacking towards the authors’ goal here. Is the policy
customization outside of scripts a large, complex space that would
benefit from using a common, principled framework to express? Or is
scripting the main source of trouble?

In the fundamentals, the authors should explain what logical connectives
denote. I understand what disjunction of categories denotes, but what
does conjunction denote (bottom left of page 2)?

In the middle of page 2, left, I get a mixed message that the authors
advocate implicit tainting of the current label, which is probably not
good for privacy. But then the same paragraph makes it sound as if the
current label must be modified explicitly before reads are allowed. I’m
guessing it’s the latter, but some rewriting of “...by accumulating
taint...” might resolve the potential for confusion.

Footnote 1 seems to be broken, or perhaps I don’t understand why a label
can have canRead twice.

Page 3

The subtlety of the intended recipient for messages should be summarized
briefly here.

I don’t know the details of the postMessage policy, but I can’t see how
it stipulates inner-most frames should not be able to read messages. Is
the text at the bottom left of the page intended to mean “given that
b.com changed the innermost frame, that frame shouldn’t be able to read
the message, as per the postMessage policy” or some such?

On the left side of the page, how can the inner-most frame (originating
at b.com) violate b.com’s confidentiality by reading a message?

Page 4

What does this label mean? canRead=https://b.com \/ https://b.com

Page 5

The statement “Since SOP does not generally prevent pages from
initiating arbitrary cross-origin requests,...” surprised me. If the
subtlety is in “initiating” rather than “completing” requests, the
authors should make it a bit more explicit, and explain what happens in
initiation of a request (that SOP will not allow to complete). 

References

Several are missing a venue.


===========================================================================
                                  Comment
               Paper #16: Toward Principled Browser Security
---------------------------------------------------------------------------
The discussion of this paper was broadly positive, however there were
several points that you would do well to address in preparing your
revised version of the paper.  First, there has been a lot of
browser+IFC work.  A bunch of the PC discussion was around whether this
was different enough from previos work in this area, so it would be
helpful to have a more concise explanation of that.  Similarly, more
discussions of the limitations of the system and, for instance, the
opportunities to integrate IFC between client and server and the
consequences of not being able to do that would be helpful.

Self-Exfiltration: The Dangers of Browser-Enforced Information Flow Control 
(http://www.w2spconf.com/2012/papers/w2sp12-final11.pdf) 

Might be worth discussing in this context.

Based on the discussion, IFC as a tool to write security policy for
browsers was very clearly the most interesting part of the paper to many
of the reviewers.



